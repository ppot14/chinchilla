package com.chinchilla.persistence;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.mybatis.spring.support.SqlSessionDaoSupport;import org.springframework.stereotype.Repository;import org.springframework.test.context.transaction.TransactionConfiguration;import org.springframework.transaction.annotation.Transactional;/** * Class contains all the basic CRUD related methods which are inherited by all * objects Children daos should generally not overwrite these method but add * extra ones as needed. */@Repository//@TransactionConfiguration(transactionManager = "transactionManager")//@Transactionalpublic abstract class MyBatisDAO<T, PK> extends SqlSessionDaoSupport implements IParentDAO<T, PK> {        private static Logger log = (Logger) LoggerFactory.getLogger(MyBatisDAO.class);    protected static final String NAMESPACE = "com.chinchilla.persistence.mappers";    protected static final String DOT = ".";//    private static final String NAMESPACE = "";//    private static final String DOT = "";            private Class<T> type;    /**     * Define prefixes for easier naming convetions between XML mapper files and     * the DAO class     *     */    public static final String PREFIX_SELECT_QUERY = "get";     //prefix of select queries in mapper files (eg. getAddressType)     public static final String PREFIX_INSERT_QUERY = "create"; //prefix of create queries in mapper files (eg. createAddressType)    public static final String PREFIX_UPDATE_QUERY = "update";  //prefix of update queries in mapper files (eg. updateAddressType)    public static final String PREFIX_DELETE_QUERY = "delete";  //prefix of delete queries in mapper files (eg. deleteAddressType)        public MyBatisDAO() throws IOException {        super();    }        public MyBatisDAO(Class<T> type) throws IOException {        super();        this.type = type;    }    /**     * @return the type     */    public Class<T> getType() {        return type;    }    /**     * @param type the type to set     */    public void setType(Class<T> type) {        this.type = type;    }    /**     * Default get by id method. </br></br> Almost all objects in the db will     * need this (except mapping tables for multiple joins, which you probably     * shouldn't even have as objects in your model, since proper MyBatis     * mappings can take care of that). </br></br> Example: </br> If your DAO     * object is called CarInfo.java, the corresponding mapper query id should     * be: &lt;select id="getCarInfo" ...     */    @Override    public T get(PK id) {       long startTime = System.currentTimeMillis();              log.debug("Parameters: " + id);        T obj = null;                String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_SELECT_QUERY + this.getType().getSimpleName();                obj = (T) getSqlSession().selectOne(query, id);              log.debug("Result: " + obj);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");        return obj;    }    /**     * Method returns all rows for this object. </br></br> Example: </br> If     * your DAO object is called CarInfo.java, the corresponding mapper query id     * should be: &lt;select id="getAllCarInfo" ... </br></br> SQL Executed:     * select * from [tablename] </br></br> Notes: </br> Consider overdiding     * this method in order to handle large numbers of objects with multiple     * references. LAZY LOADING should be enabled in this case, otherwise you     * might run out of memory (eg. get all UserAccounts if the table has     * 1,000,000 rows) look into the aggresiveLazyLoading property     *     */    @Override    public ArrayList<T> getAll() {       long startTime = System.currentTimeMillis();              log.debug("Parameters: - ");        ArrayList<T> list = null;        String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_SELECT_QUERY + "All" + this.getType().getSimpleName();                list = (ArrayList<T>) getSqlSession().selectList(query);              log.debug("Result: " + list);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");        return list;    }        @Override    public ArrayList<T> getFilteredById(Class<?> cls, Integer filter) {       long startTime = System.currentTimeMillis();              log.debug("Parameters: Class: " + cls.getSimpleName());              log.debug("Parameters: Integer: " + filter);        ArrayList<T> list = null;        String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_SELECT_QUERY + this.getType().getSimpleName() + "FilteredById" + cls.getSimpleName();                list = (ArrayList<T>) getSqlSession().selectList(query,filter);              log.debug("Result: " + list);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");        return list;    }        /**     * Method returns first object which matches the given name (exact match).     * </br></br> It's up to you to decide what constitutes an object's name.     * Typically you would have a NAME column in the table, but not all objects     * have this. Generally this method should be overriden (if you need it at     * all) in the child dao class. </br></br> Example: </br> If your DAO object     * is called CarInfo.java, the corresponding mapper query id should be:     * &lt;select id="getCarInfoByName" ... </br></br> SQL Executed (example):     * select * from [tablename] where NAME = ?     *     */    @Override    public T getByName(String name) {       long startTime = System.currentTimeMillis();              log.debug("Parameters: " + name);        T obj = null;                String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_SELECT_QUERY + this.getType().getSimpleName() + "ByName";        obj = (T) getSqlSession().selectOne(query, name);              log.debug("Result: " + obj);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");        return obj;    }    /**     * Method inserts the object into the table. </br></br> You will usually     * override this method, especially if you're inserting associated objects.     * </br> Example: </br> If your DAO object is called CarInfo.java, the     * corresponding mapper query id should be: &lt;insert id="createCarInfo"     * ... </br></br> SQL Executed (example): insert into [tablename]     * (fieldname1,fieldname2,...) values(value1,value2...) ...     *     */    @Override    public int create(T o)  {       long startTime = System.currentTimeMillis();              log.debug("Parameters: " + o);        Integer status = null;        String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_INSERT_QUERY + o.getClass().getSimpleName();        status = (Integer) getSqlSession().insert(query, o);              log.debug("Result: " + status);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");        return status;    }    /**     * Method updates the object by id. </br></br> You will usually override     * this method. But it can be used for simple objects. </br> Example: </br>     * If your DAO object is called CarInfo.java, the corresponding mapper query     * id should be: &lt;update id="updateCarInfo" ... </br></br> SQL Executed     * (example): update [tablename] set fieldname1 = value1 where id = #{id}     *     */    @Override    public int update(T o){       long startTime = System.currentTimeMillis();              log.debug("Parameters: " + o);        Integer status = null;        String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_UPDATE_QUERY + o.getClass().getSimpleName();        status = getSqlSession().update(query, o);              log.debug("Result: " + status);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");        return status;    }    /**     * Method deletes the object by id. </br></br> Example: </br> If your DAO     * object is called CarInfo.java, the corresponding mapper query id should     * be: &lt;delete id="deleteCarInfo" ... </br></br> SQL Executed (example):     * update [tablename] set fieldname1 = value1 where id = #{id}     *     */    @Override    public int delete(PK id) {       long startTime = System.currentTimeMillis();              log.debug("Parameters: " + id);        Integer status = null;                String query = NAMESPACE + DOT + this.getType().getSimpleName() + "Mappers" +  DOT +  PREFIX_DELETE_QUERY + this.getType().getSimpleName();        status = getSqlSession().delete(query, id);              log.debug("Result: " + status);              long endTime = System.currentTimeMillis();              log.info(query+" execution time: " + (endTime-startTime) + "ms");               return status;    }}